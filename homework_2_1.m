qcclear;
clc;
%разменость матрицы ( m x n )
m = 5;
n = 4;
R = 1.5;
tol = 0.01; %точность
res = 1;
top = 0; %потенциал верхнего проводника
right = 5; %потенциал правого проводника
left = 15; % потенциал левого проводника
down = 10; %потенциал нижнего проводника

nodes(m,n) = zeros;

%задаем граничны условия
%порядок записи не имеет значения,
%т.к. узлы в углах не используются
nodes(1,:) = top;
nodes(m,:) = down;
nodes(:,1) = left;
nodes(:,n) = right;

%начальные условия цикла
N = 1; %счетчик итераций

%цикл решателя
while (res>tol)
%перебор по всем внутренним узлам
for i = 2:m-1
for j = 2:n-1
temp = nodes;%записываем результат текущей итерации
last = nodes(i,j); %переменная для хранения значений предыдущей итерации
%вычисление центрального элемента пятиточечного шаблона
nodes(i,j) = (((nodes(i-1,j) + nodes(i+1,j) + nodes(i,j-1) + nodes(i,j+1))/4)+(1 - R)*last)*R;
%считаем нормы
n1 = norm(nodes-temp);
n2 = norm(temp);
res = n1/n2;
N = N + 1;
endfor
endfor
endwhile
%обрезаем граничные елементы
nodes(m,:) = [];
nodes(1,:) = [];
nodes(:,n) = [];
nodes(:,1) = [];
%вывод результатов на экран
nodes
N
